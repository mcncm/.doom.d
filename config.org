#+AUTHOR: mcncm
#+PROPERTY: header-args :emacs-lisp :tangle yes :comments no :cache yes :results silent
#+STARTUP: org-startup-folded: showall
* Introduction
I’ve been migrating from [[https://www.spacemacs.org/][Spacemacs]] to [[https://github.com/hlissner/doom-emacs][Doom Emacs]], which has made it easier than ever to write a maintainable, human-readable config document. This represents my “first best effort” at translating my previous config.
** Conventions
+ “Personal” variables and functions have the prefix ~my/~ as a namespacing convention.
* Default Doom config preamble
:PROPERTIES:
:ID:       a7970dd7-441a-41b8-8401-68f15511ea0f
:END:
Use lexical binding /always/; otherwise, ~let~ constructs will not behave intuitively. Note that for this header to work properly in a literate config, we must include the ~:comments no~ attribute in the headers above, and it must come /after/ ~:tangle yes~. You can also set this attribute for each block.

#+BEGIN_SRC emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+END_SRC

This is just the block at the top of the ~config.el~ that ships with Doom Emacs, modified to my current tastes. There’s nothing especially interesting here.

#+BEGIN_SRC emacs-lisp
;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!

;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
(load "~/.doom.d/secrets.el")

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/org")

;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
;;
;; + `doom-font'
;; + `doom-variable-pitch-font'
;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string. You generally only need these two:
;; (setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
;;       doom-variable-pitch-font (font-spec :family "sans" :size 13))
(setq my/code-family "FiraCode Nerd Font")
;; (setq my/code-family "Fantasque Sans")
(setq my/code-size 20)
;; (setq my/text-family "Georgia")
;; (setq my/text-family "Iosevka")
(setq my/text-family "XETBook")
;;(setq my/text-family "CrimsonText")
;; (setq my/text-family "National Park")
(setq my/text-size 25)

(setq doom-font (font-spec :family my/code-family :size my/code-size)
      doom-big-font (font-spec :family my/code-family :size 30)
      doom-variable-pitch-font (font-spec :family my/text-family :size my/text-size :weight 'thin))

(setq doom-unicode-font (font-spec :family "DejaVu Sans Mono" :size my/code-size))

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
;;(setq doom-theme 'ewal-doom-one)

;; NOTE doom-theme is set below, after the banner configuration.

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type 'relative)


;; Here are some additional functions/macros that could help you configure Doom
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
#+END_SRC

* Generalities
** System things
:PROPERTIES:
:ID:       09950f0e-0bc9-44d9-8487-09cdd7052611
:END:
Here are some directories I want to keep track of.
#+begin_src  emacs-lisp
(setq
  my/nixos-dir "~/.config/nixos"
  my/server-homedir (concat
                     "/ssh:mcncm@"
                     my/home-server-hostname
                     ":/home/mcncm")
  my/org-agenda-dir (concat
                     org-directory
                     "/agenda"))
#+end_src
** Some better defaults
:PROPERTIES:
:ID:       1d69347d-73fc-40b9-a2f2-9a3bc6b42e95
:END:
I’d like to set some variables that generally make life better.

Here I’m trying to more closely match the [[https://www.spacemacs.org/][Spacemacs]] convention that I like. I'm still not sure what the default “repeat” behavior of the comma key actually /does/. For all I know, I might prefer it. In any case, I should also see if I ought to unmap that key first. Note that this *unmaps* ~SPC-m~.

#+BEGIN_SRC emacs-lisp
(setq doom-localleader-key ",")
#+END_SRC

It takes a while for the which-key tips to come up. Make it faster.

#+begin_src emacs-lisp
(setq which-key-idle-delay 0.25)
#+end_src

And here are some miscellaneous settings.  All of these are snagged from [[https://tecosaur.github.io/emacs-config/config.html#better-defaults][tecosaur]], who in turn got them from a much larger list of “better defaults” from [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon]].

#+BEGIN_SRC emacs-lisp
(setq-default
 delete-by-moving-to-trash t)

(setq undo-limit 80000000
      truncate-string-ellipsis "…")
#+END_SRC

I’d also like to add this so tramp will work properly on my NixOS server.
#+BEGIN_SRC emacs-lisp
(after! tramp
  (add-to-list 'tramp-remote-path "/run/current-system/sw/bin"))
#+END_SRC

The large-file-size confirmation should be a bit bigger -- I keep getting asked for confirmation to open ~.pdf~ papers.
#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 20000000)
#+END_SRC

I’ve just encountered an image scaling issue that sometimes makes inline raster images look awful. Rather than the default ~'auto~ value, they should be unscaled.
#+begin_src emacs-lisp
(setq image-scaling-factor 1)
#+end_src

By default, Doom uses a variable-pitch font for treemacs. Let’s fix that. However, this doesn’t fully work, as it gets reset when you change themes. It’s also not clear how to use a /specific/ font of choice. See [[https://github.com/hlissner/doom-emacs/issues/1551][this issue]].
#+begin_src emacs-lisp
(after! doom-themes-ext-treemacs
  (setq doom-themes-treemacs-enable-variable-pitch nil))
#+end_src

Why would I /ever/ want the whole buffer to remain highlighted after a substitute operation?

#+begin_src emacs-lisp
(setq evil-ex-search-persistent-highlight nil)
#+end_src

** Some extra bindings
:PROPERTIES:
:ID:       1bff5219-551e-42f7-94da-91a5aadcbf82
:END:
I’m always turning electric quotes on and off, so it helps to have this bound for quick access. It might be even better to set up the package to understand when it’s in a source block and so on. Let’s toggle treemacs, too.
#+BEGIN_SRC emacs-lisp
(map! :leader
      :prefix ("t")
      :desc "Electric quote local mode"
      "q" #'electric-quote-mode
      :desc "Treemacs"
      "t" #'treemacs)
#+END_SRC

Project-level ~make~ seems like a nice thing to have.
#+begin_src emacs-lisp
(map! :leader
      :desc "Make"
      "m" #'+make/run)
#+end_src

** “Verbal” bindings and tidbits
:PROPERTIES:
:ID:       dc5af299-6de5-4a09-b16f-b90875658c59
:END:
Google translate, which we're not using right now.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package! google-translate
  :config
  (setq google-translate-default-target-language "English"))
#+END_SRC

There are a few functions I’d really like bound to keyboard shortcuts that aren’t by default. ~v~ is unused for now, so I’ll take advantage of it, particularly for /verbal/ functions.

#+BEGIN_SRC emacs-lisp
(map!
 :leader
 :prefix ("v" . "words")
 (:after spell-fu
  "a" #'spell-fu-word-add
  "r" #'spell-fu-word-remove)
 (:after google-translate
  (:prefix-map ("t" . "translate")
  :desc "Translate dwim"
  "t" #'(lambda () (google-translate-at-point '(nil nil)))
  :desc "Translate at point"
  "T" #'google-translate-at-point
  :desc "Translate buffer"
  "b" #'google-translate-buffer
  :desc "Query translate"
  "q" #'google-translate-query-translate)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! (popup google-translate)
  (set-popup-rule! "^\\*Google Translate"
    ;; :action
    :height 0.3   ;; fill this much of the screen
    ))
#+END_SRC

I’d also like my dictionary popups to fill a little more of the screen than they do by default.

#+BEGIN_SRC emacs-lisp
(after! popup
  (set-popup-rule! "^\\*WordNut"
    ;; :action
    :height 0.3   ;; fill this much of the screen
    ))
#+END_SRC
*** Dictionary settings
:PROPERTIES:
:ID:       7a1495de-60e4-4567-baa7-f94a38ff1f35
:END:
I couldn’t figure out how to make this work until following tecosaur. Thanks, tecosaur.
#+BEGIN_SRC emacs-lisp
(setq ispell-dictionary "en"
      ispell-personal-dictionary (expand-file-name
                                  ".ispell_personal"
                                  doom-private-dir))
#+END_SRC

** Little helper functions
:PROPERTIES:
:ID:       ec5d3954-a5a9-40fc-bfb9-bfb2e40e71b9
:END:
There are no longer any helper functions here. I should figure out where to put these key bindings.

#+BEGIN_SRC emacs-lisp
(map! :map doom-leader-file-map
      :leader
      :prefix ("f" . "file")  ;; Is there a way to do this without getting the prefix just so?
      :desc "Find file in home"
      "h" #'(lambda () (interactive) (ido-find-file-in-dir "~"))
      :desc "Find file in home/tmp"
      "t" #'(lambda () (interactive) (ido-find-file-in-dir "~/tmp"))
      :desc "Find file in agenda"
      "a" #'(lambda () (interactive) (ido-find-file-in-dir my/org-agenda-dir))
      :desc "Find file in nixos config"
      "n" #'(lambda () (interactive) (ido-find-file-in-dir my/nixos-dir))
      :desc "Find file on server"
      "b" #'(lambda () (interactive) (ido-find-file-in-dir my/server-homedir)))
#+END_SRC

Here are two little auxiliary functions for retrieving palette colors. I’m not sure if there’s already a (presumably Doom-specific) function that accomplishes this, but if there is I should use it.

#+BEGIN_SRC emacs-lisp
(defun my/ewal-color (color)
  "COLOR should be a symbol defined in ewal-base-palette. Options are:
'comment, 'background, 'foreground, 'cursor, 'black, 'red,
'green, 'yellow, 'blue, 'magenta, 'cyan, 'white"
  (cdr (assoc color ewal-base-palette)))

(defun my/theme-color (color)
  "A generalization of `my/ewal-color` that should with for all Doom themes. COLOR should be a key in `doom-themes--colors`. Returns a hex code."
  (let ((color-spec                 ;; a list with four elements
         (seq-find
         (lambda (x) (eq (car x) color)) ;; take the matching one
         doom-themes--colors)))
    (if color-spec
        (car (cdr color-spec))      ;; return the second elemend
      nil)                          ;; …if it exists.
    ))
#+END_SRC

** Behold the dodecahedron!
:PROPERTIES:
:ID:       885b2cc1-cf4f-4207-a2af-b9dd30d6edad
:END:
This is my Doom banner, or splash screen icon. It's chosen randomly from a directory full of banner options. One of these is a dodecahedron that I'm quite fond of.

#+BEGIN_SRC emacs-lisp
(setq +doom-dashboard-banner-dir "~/.doom.d/banner"
      ;; Now pick a random banner!
      ;; my/banner-template-file (concat
      ;;                          +doom-dashboard-banner-dir "/"
      ;;                          (seq-random-elt
      ;;                          (directory-files
      ;;                           +doom-dashboard-banner-dir t
      ;;                           directory-files-no-dot-files-regexp)))
      my/banner-template-file (concat
                               +doom-dashboard-banner-dir "/"
                               "EmackPartialEdit.png")
      +doom-dashboard-banner-file
      (let
          ((ext
            (file-name-extension my/banner-template-file)))
        (concat +doom-dashboard-banner-dir "/banner." ext)))
#+END_SRC

A fun little trick and terrible hack to recolor the banner. Maybe I should try ~async-shell-command~ rather than ~shell-command~? We can even set an override color on a per-theme basis.

#+BEGIN_SRC emacs-lisp
;; TODO I think I'm probably supposed to ~defvar~ these so they're properly
;; documented.

(setq my/theme-banner-color-overrides
      '((doom-gruvbox-light . red)
        (poet . yellow))
      my/banner-color-default 'blue)

(defun my/theme-banner-color ()
  "Get the preferred banner color for the current `doom-theme` as a hex code."
  (let* ((pair (seq-find
                (lambda (pair) (eq (car pair) doom-theme))
                my/theme-banner-color-overrides))
         (color (if pair (cdr pair) my/banner-color-default)))
    (my/theme-color color)))

(defun my/recolor-banner ()
  "Recolor the banner image to the preferred color for the current theme."
  (shell-command
   (if (eq (file-name-extension my/banner-template-file) "svg")
       (concat "sed -e \""
               ;; replace black with the banner color
               "s/#000000/" (my/theme-banner-color) "/g" "; "
               ;; replace white with background color
               "s/#FFFFFF/" (my/theme-color 'bg) "/g" "\" "
               my/banner-template-file " > "
               +doom-dashboard-banner-dir "/" +doom-dashboard-banner-file)
     (concat "cp "
             my/banner-template-file " " +doom-dashboard-banner-file))))
#+END_SRC

(shell-command(concat "cp " my/banner-template-file " " +doom-dashboard-banner-file) )

Let’s run this when we change themes, so it’s colored correctly. I guess that was a little ugly, since ~my/banner-template-file~ is an absolute path, while ~+doom-dashboard-banner-file~ is relative to ~+doom-dashboard-banner-dir~.

#+BEGIN_SRC emacs-lisp
(add-hook! 'doom-load-theme-hook #'my/recolor-banner)
#+END_SRC
** Finally, load a theme
:PROPERTIES:
:ID:       5e2bc1ed-a72b-4ba1-8be5-4f6e3be07246
:END:
We put this off until now because we had to set that hook. Otherwise the splash image would not be colored properly on startup.
#+begin_src emacs-lisp
(load-theme 'ewal-doom-one t)
#+end_src
Honestly, this slows down startup by a little bit. Maybe half of a second. Does look cool, though.
** Odds and ends
:PROPERTIES:
:ID:       6da9996e-9d26-4e24-a74a-a0d3ceb4e157
:END:
See ~all-the-icons~ major mode icon in modeline
#+BEGIN_SRC emacs-lisp
(setq-default doom-modeline-major-mode-icon t)
#+END_SRC

A fun little thing you can do in Emacs 27. Function due to an internet stranger, whom I should cite if I ever find them again.

#+BEGIN_SRC emacs-lisp
(defun screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring."
  (interactive)
  (let* ((filename (make-temp-file "Emacs" nil ".svg"))
         (data (x-export-frames nil 'svg)))
    (with-temp-file filename
      (insert data))
    (kill-new filename)
    (message filename)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
;; alert configurations
(after! alert
  (setq-default alert-default-style 'libnotify
                ;; alerts fade out after 30 seconds
                alert-fade-time 30))

(add-hook 'after-init-hook 'org-wild-notifier-mode)
#+END_SRC

* Fonts, faces, and characters
** Better color defaults
:PROPERTIES:
:ID:       29623dd3-d44a-4bf6-a8aa-7f7b7142c154
:END:
Fix some pretty awful ~lsp~ colors. To check: are all these ~after!~ macros expensive? Are they hurting my startup time? Should I be putting them in some specific order?

#+BEGIN_SRC emacs-lisp
(after! lsp-modeline
  (after! ewal-doom-themes
    (set-face-attribute 'lsp-modeline-code-actions-face nil
                        :foreground (my/ewal-color 'cyan))))
#+END_SRC

Coq-related face settings from my old Spacemacs config, which are not exactly correct any more.

#+BEGIN_SRC emacs-lisp
;; Change the color-setting from the version, wrap in 'set-face-attribute' call
;; (proof-locked-face :background ,(ewal-get-color 'background 2))
#+END_SRC

** Org faces
:PROPERTIES:
:ID:       cf7d0273-4734-4592-9ee0-5bad74f7753e
:END:
Some sensible org theme things. I think I snagged these from [[https://github.com/biblecraft-abe/Spacemacs][Abraham Peters]].

#+BEGIN_SRC emacs-lisp
(let* ((base-font-color     (face-foreground 'default nil 'default))
       ;; ~headline~ previously had a ~:foreground ,base-font-color~ in it. But
       ;; this seems not to give the right color--all headlines come out black.
       (headline           `(:inherit default :weight bold)))
  ;; A Doom Emacs macro that provides a simpler syntax for `custom-theme-set-faces`
  (custom-theme-set-faces!
    'user
    ;; nil
    ;; Why does 0.8 seem to be about right? Well, it’s the same as the ratio
    ;; between my/code-size and my/text-size. That’s probably a hint as to
    ;; what’s going on.
    `(org-latex-and-related :family ,my/code-family :height 0.8)
    `(org-code :family ,my/code-family :height 1.0)
    `(org-block-begin-line :height 1.0) ;; What do I have to do with this
    `(org-block :family ,my/code-family :height 0.8)
    `(org-drawer :inherit default :family ,my/code-family)
    `(org-special-keyword :inherit default :family ,my/code-family)
    `(org-level-8 ,@headline)
    `(org-level-7 ,@headline)
    `(org-level-6 ,@headline)
    `(org-level-5 ,@headline)
    `(org-level-4 ,@headline :height 1.1)
    `(org-level-3 ,@headline :height 1.25)
    `(org-level-2 ,@headline :height 1.5)
    `(org-level-1 ,@headline :height 1.75)
    `(org-document-title ,@headline :height 2.0 :underline nil)))
#+END_SRC

Block faces: which faces should we use for which source languages?
Need to set ~org-src-block-faces~, and we should set it /before/ loading org mode.

#+BEGIN_SRC emacs-lisp
(setq org-src-block-faces
      `(("python" (:family ,my/code-family))
        ("jupyter-python" (:family ,my/code-family))
        ("rust" (:family ,my/code-family))
        ("jupyter-julia" (:family ,my/code-family))
        ("emacs-lisp" (:family ,my/code-family))
        ("cavy" (:family ,my/code-family))
        ("silq" (:family ,my/code-family))))
#+END_SRC
** Ligatures
:PROPERTIES:
:ID:       21847da1-0eed-427c-895b-599a9f3e589a
:END:
Fira Code is a pretty nice programming font, and I like its ligatures and special characters. But some of them, like rendering ~x~ as a multiplication sign, are a little ugly.

This block is currently excluded (~:tangle no~) because ~fira-code-mode~ seems to not play well with the ~ligatures~ module. I’m not sure how to successfully get Fira ligatures as well as all the others.

#+BEGIN_SRC emacs-lisp :tangle no
(custom-set-variables '(fira-code-mode-disabled-ligatures '("[]" "#{" "#(" "#[" "#_(" "x")))
(add-hook 'prog-mode-hook 'fira-code-mode)
#+END_SRC

Let’s set the disabled ligatures for the ~+ligatures~ package.
#+begin_src emacs-lisp

#+end_src
* Programming
** Rust
:PROPERTIES:
:ID:       8ecc080b-0c4b-4f57-98b9-42458275523a
:END:

Let’s give ourselves a little function to create a new Rust project and pop into ~lib.rs~

#+begin_src emacs-lisp
(setq my/proj-dir "~/proj")

(defun my/cargo-new ()
  "Create a new cargo project and open `lib.rs'"
  (interactive)
  (let ((proj (concat my/proj-dir "/"
                      (read-string "Crate name: "))))
    (progn
      ;; First, create it
      (shell-command (concat "cargo new --lib " proj))
      ;; Then, open a new buffer
      (find-file (concat proj "/src/lib.rs")))))
#+end_src

Not necessary if using ~:editor format-all~ (or something like this? I forget what the setting was called), but that seems not to work. In any case, I think I might prefer ~rust-mode~ to ~rustic~. I might consider going back, even within Doom.

#+BEGIN_SRC emacs-lisp :tangle no
(after! rustic
    (setq rustic-format-on-save t))
#+END_SRC

I want to ensure that my compilation buffers show up on the right-hand side. Check the documentation for ~set-popup-rule!~ to find out about all the keys you can use for this.

#+BEGIN_SRC emacs-lisp
(setq my/rustic-popup-position 'right)
(setq my/rustic-popup-width 0.40)

(defun my/set-rustic-popup-rules ()
  "Declare popup rules for rustic-mode"
  (progn
    (set-popup-rule! "^\\*rustic"
      ;; :select t    ;; focus the window after it opens
      ;; :action
      :side my/rustic-popup-position
      :width my/rustic-popup-width ;; and fill 40% of it.
      :quit 'current)
    (set-popup-rule! "^\\*cargo-"
      ;; :select t    ;; focus the window after it opens
      ;; :action
      :side my/rustic-popup-position
      :width my/rustic-popup-width ;; and fill 45% of it.
      :quit 'current)))

(defmacro my/rustic-set-popup-pos (var)
  `(lambda () (interactive)
     "Declare the side of the screen for rustic-mode popups."
     (progn
       (setq my/rustic-popup-position ,var)
       (my/set-rustic-popup-rules))))

(defmacro my/modify-rustic-popup-width (delta)
  `(lambda () (interactive)
     (progn
       (setq my/rustic-popup-width
        (min 1.0
             (max 0.0
                  (+ ,delta my/rustic-popup-width))))
       (my/set-rustic-popup-rules))))

(after! rustic
  (my/set-rustic-popup-rules))
#+END_SRC

It is sometimes advised, I think, to abrogate the use of advice. But I thought it would be much nicer to use this approach here than to define an entirely /new/ function and to bind it to some unused key or to override the binding for  ~rustic-cargo-run~. This is a much simpler version of the function ~cargo-comint-run~  appearing in my Spacemacs config.

#+BEGIN_SRC emacs-lisp :tangle no
(defadvice! cargo-run-comint ()
  "After calling `rustic-cargo-run`, enter comint mode and make the buffer editable."
  :after #'rustic-cargo-run
  (switch-to-buffer-other-window "*rustic-compilation*")
  (comint-mode))
;; (with-current-buffer (get-buffer "*rustic-compilation*")
;;   (comint-mode))
;; (evil-goto-line))
;; (sleep-for 1)
;;  (comint-mode)
;;  (read-only-mode 0)
;;  (evil-goto-line)
;;  (evil-append-line))
;; (read-only-mode 0))
#+END_SRC

I’d also like to be able to enjoy a development style that feels a little like Coq development, where I refactor by making a single local edit, then following the error messages until the program type-checks again. To this end, let’s set up a command to start a ~cargo-watch~ session.

#+begin_src emacs-lisp
(defun my/rustic-cargo-build-release ()
  "Do a release build"
  (interactive)
  (rustic-run-cargo-command "cargo build --release"))

(defun my/rustic-cargo-run-release ()
  "Do a release build"
  (interactive)
  (rustic-run-cargo-command "cargo run --release"))

(defun my/rustic-cargo-test ()
  "Run all tests in the current default directory"
  (interactive)
  (rustic-run-cargo-command
   "cargo test --no-fail-fast"))
#+end_src

A helpful little function to add dependencies with ~cargo-add~

#+begin_src emacs-lisp
(defun my/cargo-add ()
    (interactive)
  (shell-command
   (concat "cargo add "
           (read-string
            "cargo-add: "
            (my/crate-at-point)))))

(defun my/crate-at-point ()
  (s-replace "_" "-" (current-word)))
#+end_src

#+BEGIN_SRC emacs-lisp
(defmacro my/toggle (var)
  `(lambda () (interactive)
     (progn
       (setq ,var (not ,var))
       (message (concat (symbol-name ',var)
                        " is now "
                        ;; How are you supposed to format booleans in Elisp?
                        (if ,var "t" "nil"))))))

(map! :after rustic
      :map rustic-mode-map
      :localleader

      :desc "Expand macro at point"
      "e" #'lsp-rust-analyzer-expand-macro

      :desc "Add dependency"
      "d" (lambda () (interactive) (my/cargo-add))

      :prefix "b"
      (:prefix ("w" . "cargo watch")
       :desc "cargo watch -x check"
       "c" #'my/rustic-cargo-watch-check
       :desc "cargo watch -x run"
       "r" #'my/rustic-cargo-watch-run)
       :desc "cargo run --release"
       "R" #'my/rustic-cargo-run-release

      :prefix "t"
      :desc "all"
      "a" #'my/rustic-cargo-test
      :prefix ("p" . "popups")
      :desc "Popup left"
      "h" (my/rustic-set-popup-pos 'left)
      :desc "Popup right"
      "l" (my/rustic-set-popup-pos 'right)
      :desc "Popup bottom"
      "j" (my/rustic-set-popup-pos 'bottom)
      :desc "Embiggen popup"
      "+" (my/modify-rustic-popup-width 0.05)
      :desc "Srink popup"
      "-" (my/modify-rustic-popup-width -0.05)
      :prefix ("T" . "toggle")
      :desc "Toggle format on save"
      "f" (my/toggle rustic-format-on-save)
      :desc "Toggle cargo-check on save"
      "c" (my/toggle my/rustic-cargo-check-on-save))
#+END_SRC

#+begin_src emacs-lisp
(after! rustic
  (setq rustic-compile-directory-method #'rustic-buffer-crate))
#+end_src

** Python
:PROPERTIES:
:ID:       a35914a2-c500-43d4-bf52-97239c27e509
:END:
For some reason, Doom’s Python module is relatively impoverished compared to the Spacemacs Python layer, in that few of the keybindings are evil-ified. I’m trying to make up the difference here.

First, a little helper macro for do-and-switch-to-window functions, which will be helpful for defining these keybindings:

#+BEGIN_SRC emacs-lisp
(defmacro my/do-and-switch (action buffer-name)
  "Accepts some ACTION and BUFFER-NAME, and produces a lambda that performs the action and switches to the window presenting the corresponding buffer."
  `(lambda ()
    (interactive)
    (,action)
    (let ((win (display-buffer ,buffer-name nil 'visible)))
      (select-window win))))
#+END_SRC

Now let’s use that macro to set some bindings. I should modify this so that ~i~ starts a repl if there is none, and runs ~python-shell-switch-to-shell~ if there is not. Also, these are producing ~Wrong number of arguments~ errors for some reason.

#+BEGIN_SRC emacs-lisp
(map! :after python
      :map python-mode-map
      :localleader
      :prefix ("s" . "shell")
      :desc "Run IPython REPL"
      "i" #'+python/open-ipython-repl
      :desc "Run IPython REPL and switch"
      "I" (my/do-and-switch +python/open-ipython-repl "*Python*")
      :desc "Send statement"
      "s" #'python-shell-send-statement
      :desc "Send statement and switch"
      "S" (my/do-and-switch python-shell-send-statement "*Python")
      :desc "Send region"
      "s" #'python-shell-send-region
      :desc "Send region and switch"
      "S" (my/do-and-switch python-shell-send-region "*Python")
      :desc "Send buffer"
      "b" #'python-shell-send-buffer
      :desc "Send buffer and switch"
      "B" (my/do-and-switch python-shell-send-buffer "*Python*")
      :desc "Send file"
      "f" #'python-shell-send-file
      :desc "Send file and switch"
      "F" (my/do-and-switch python-shell-send-file "*Python*"))
#+END_SRC

I also want the shell to feel less ‘transient.’

#+BEGIN_SRC emacs-lisp
(after! popup
  (set-popup-rule! "^\\*Python"
    :select nil  ;; don’t auto-focus the window
                 ;; instead, use the commands defined above
    ;; :action
    :side 'right ;; on the rhs of the screen
    :width 0.5   ;; and fill 50% of it.
    :quit nil
  )
  (set-popup-rule! "^\\*pytest*"
    :select nil  ;; don’t auto-focus the window
                 ;; instead, use the commands defined above
    ;; :action
    :side 'right ;; on the rhs of the screen
    :width 0.5   ;; and fill 50% of it.
    :quit nil
  )
)
#+END_SRC

Finally, I want to get rid of the default ligatures from the ~ligatures~ module. If there’s a cleaner way to accomplish this (say, with a single built-in function, or by setting a ~ligatures~ module variable), I’d like to know.

This /doesn’t quite work/ right now. In particular, the /first/ python buffer will have all the undesired default ligatures, while subsequent ones will only have the one(s) specified here.

#+BEGIN_SRC emacs-lisp
(after! python
  (set-ligatures! 'python-mode nil) ;; remove the defaults
  (set-ligatures! 'python-mode  ;; and insert new ones
    :lambda "lambda"))
#+END_SRC
** C/C++
:PROPERTIES:
:ID:       8068077e-30ad-4645-8183-3ab10a614328
:END:
No ligatures, please!
#+BEGIN_SRC emacs-lisp
(after! cc-mode
  (set-ligatures! 'c++-mode nil)
  (set-ligatures! 'c-mode nil))
#+END_SRC
** Julia
:PROPERTIES:
:ID:       96c0dcbc-3987-406e-8421-377694e985be
:END:
Override the default 1.0 environment for my actual Julia version.
#+BEGIN_SRC emacs-lisp
(setq lsp-julia-default-environment "~/.julia/environments/v1.5")
#+END_SRC
** Mathematica
I’d like to use Mathematica within Org-mode. This first pass is taken from [[https://rgoswami.me/posts/org-mathematica/][Rohit Goswami]].
#+begin_src emacs-lisp :tangle no
;; Load mathematica from contrib
(org-babel-do-load-languages 'org-babel-load-languages
                             (append org-babel-load-languages
                                     '((mathematica . t))
                                     ))
;; Sanitize output and deal with paths
(setq org-babel-mathematica-command "~/.local/bin/mash")
;; Font-locking
(after! ob-mathematica
  (add-to-list 'org-src-lang-modes '("mathematica" . wolfram)))
;; For wolfram-mode
(setq mathematica-command-line "~/.local/bin/mash")
#+end_src
** Haskell
# :PROPERTIES:
# :ID:       a9e8e127-2e8e-46b3-bfad-33478c8f4986
# :END:
# #+begin_src emacs-lisp
# (after! org
#   (require 'ob-haskell))
# #+end_src
** Cavy
:PROPERTIES:
:ID:       2dfd70ed-8272-4152-b763-3f1902b28d52
:END:
Cavy is a little programming language I’m working on for fun. We should turn on its major mode while editing Cavy source.
#+begin_src emacs-lisp
(load-file "~/proj/cavy/cavy-mode/cavy-mode.el")
(setq cavy-binary "~/proj/cavy/cavy-lang/target/debug/cavyc")
(setq cavy-alt-binary "~/.cargo/bin/cavyc")
(add-to-list 'auto-mode-alist '("\\.cavy\\'" . cavy-mode))
(add-to-list 'auto-mode-alist '("\\.cv\\'" . cavy-mode))

(defun my/org-babel-cavy-base-build-cmd (input output)
  (concat cavy-binary " " input " -o " output " --target latex --nwtarg --initial-kets"))

(defun org-babel-execute:cavy (body params)
  "Orgmode Babel Cavy evaluate function for `BODY' with `PARAMS'."
  ;; This command is a hack to get stderr into the output. `org-babel-execute'
  ;; is supposed to put stderr into a special buffer on error. So, we make it
  ;; always succeed (~|| true~) and redirect stderr to stdout. Together, this
  ;; lets us capture error messages!
  (let* ((cmd (concat (my/org-babel-cavy-base-build-cmd "/dev/stdin" "/dev/stdout") " 2>&1 || true")))
    (org-babel-eval cmd body)))

;; Syntax highlighting in exported code
;; (push '(cavy "rust") org-latex-minted-langs)

;; Huh, this doesn't seem to do the trick.
(after! all-the-icons
  (add-to-list 'all-the-icons-data/file-icon-alist
               '("cavy" . "")))
#+end_src

I also want to override its default indent function with a good one from a more professional major mode:

#+begin_src emacs-lisp
(after! cavy-mode
  ;; TODO: (require 'rustic) or something?
  (defun cavy-indent-line ()
    "Indent a line of Cavy code using the indent function from `rustic'."
    (rustic-indent-line)))
#+end_src

Another utility I'd like to have is the ability to set a watch on a file and display the Cavy compiler output every time I compile the Rust project.

#+begin_src emacs-lisp
;; first of all, initialize the watched-buffer variable
(setq my/watched-cavy-buffer 'nil)

;; could improve by filtering the buffers
(defun my/ivy-select-cavy-buffer ()
  "Watch a Cavy buffer."
  (interactive)
  (ivy-read "Watch Cavy buffer: " #'internal-complete-buffer
            :keymap ivy-switch-buffer-map
            :preselect (buffer-name (other-buffer (current-buffer)))
            :action #'my/watch-cavy-buffer
            :matcher #'ivy--switch-buffer-matcher
            :caller 'my/ivy-select-cavy-buffer))

(defun my/watch-cavy-buffer (name-of-buffer)
  (progn
    ;; get rid of the last hook, if there was one
    (if (and my/watched-cavy-buffer
             (get-buffer my/watched-cavy-buffer))
        (with-current-buffer my/watched-cavy-buffer
          (remove-hook! 'kill-buffer-hook :local
            #'my/clear-watched-cavy-buffer)))
    ;; now set the new buffer
    (setq my/watched-cavy-buffer name-of-buffer)
    ;; and put the hook on the new one
    (with-current-buffer my/watched-cavy-buffer
      (add-hook! 'kill-buffer-hook :local
                 #'my/clear-watched-cavy-buffer))))

(defun my/clear-watched-cavy-buffer ()
  (interactive)
  (setq my/watched-cavy-buffer 'nil))

;; run `cargo build` with a sentinel that will run the watch command(s) on
;; completion. As a matter of fact, this will be useful for all sorts of things.
;; Right now I'm just using it for Cavy, but I really should refactor it so it
;; can be useful for all sorts of projects
;; (defun my/rustic-cargo-build-watch ()
;;   (interactive)
;;   (rustic-run-cargo-command
;;    "cargo build"
;;    '(:sentinel my/rustic-watch-sentinel)))

(defun my/rustic-cargo-watch-run ()
  (interactive)
  (rustic-run-cargo-command
   "cargo watch -x run"))

(defun my/rustic-cargo-watch-check ()
  (interactive)
  (rustic-run-cargo-command
   "cargo watch -x check"))

(defun my/rustic-watch-sentinel (process event)
  (progn
    (compilation-sentinel process event)
    (if (string= event "finished\n")
        (my/rustic-watched-file-actions))))


;; finally, actually do the action(s)
(defun my/rustic-watched-file-actions ()
  ;; at the moment, just do the Cavy thing
  (if my/watched-cavy-buffer
      (with-current-buffer my/watched-cavy-buffer
        (cavy-compile-and-preview))))
#+end_src

And we should set up some evil keybindings for it:

#+begin_src emacs-lisp
(map! :after cavy-mode
      :map cavy-mode-map
      :localleader
      :desc "compile"
      "c" #'cavy-compile-and-preview
      :desc "compile-alt"
      "C" #'(lambda () (interactive)
              (let ((old cavy-binary))
                (progn
                  (setq cavy-binary cavy-alt-binary)
                  (cavy-compile-and-preview)
                  (setq cavy-binary old))))
      :desc "toggle debug mode"
      "d" (lambda () (interactive) (cavy-toggle-opt 'debug))

      (:prefix ("t" . "target")
       :desc "set summary compile target"
       "s" (lambda () (interactive) (cavy-set-opt 'target "summary"))
       :desc "set QASM compile target"
       "q" (lambda () (interactive) (cavy-set-opt 'target "qasm"))
       :desc "set debug compile target"
       "d" (lambda () (interactive) (cavy-set-opt 'target "debug"))
       :desc "set LaTeX compile target"
       "l" (lambda () (interactive) (cavy-set-opt 'target "latex")))

      (:prefix ("l" . "LaTeX")
       :desc "toggle standalone"
       "s" (lambda () (interactive) (cavy-toggle-opt 'standalone))
       :desc "toggle kets"
       "k" (lambda () (interactive) (cavy-toggle-opt 'initial-kets))
       :desc "toggle wave"
       "w" (lambda () (interactive) (cavy-toggle-opt 'wave))
       :desc "set quantikz package"
       "z" (lambda () (interactive) (cavy-set-opt 'package "quantikz"))
       :desc "set qcircuit package"
       "c" (lambda () (interactive) (cavy-set-opt 'package "qcircuit"))
       :desc "set yquant package"
       "y" (lambda () (interactive) (cavy-set-opt 'package "yquant")))

      (:prefix ("p" . "phase")
       :desc "parse"
       "p" (lambda () (interactive) (cavy-set-opt 'phase "parse"))
       :desc "lower to MIR"
       "l" (lambda () (interactive) (cavy-set-opt 'phase "typecheck"))
       :desc "static analysis"
       "a" (lambda () (interactive) (cavy-set-opt 'phase "analysis"))
       :desc "lower and optimize"
       "o" (lambda () (interactive) (cavy-set-opt 'phase "optimization"))
       :desc "translate to LIR"
       "t" (lambda () (interactive) (cavy-set-opt 'phase "translation"))
       :desc "compile object code"
       "c" (lambda () (interactive (cavy-set-opt 'phase 'nil))))

      (:prefix ("m" . "measurement")
       :desc "demolition"
       "d" (lambda () (interactive) (cavy-set-opt 'meas-mode "demolition"))
       :desc "nondemo"
       "n" (lambda () (interactive) (cavy-set-opt 'meas-mode "nondemolition"))
       :desc "dirty"
       "D" (lambda () (interactive) (cavy-set-opt 'meas-mode "dirty")))

      (:prefix ("o" . "optimization")
       :desc "toggle constant propagation"
       "c" (my/toggle cavy-comptime)
       :desc "no optimization"
       "0" (lambda () (interactive) (cavy-set-opt 'opt-level 0))
       :desc "O1"
       "1" (lambda () (interactive) (cavy-set-opt 'opt-level 1))
       :desc "O2"
       "2" (lambda () (interactive) (cavy-set-opt 'opt-level 2))
       :desc "O3"
       "3" (lambda () (interactive) (cavy-set-opt 'opt-level 3))))
#+end_src
** Silq
:PROPERTIES:
:ID:       2d21ee0c-5021-4359-901a-9ddbe5b0d4e0
:END:
Let’s get some block-evaluation going on for Silq.
#+begin_src emacs-lisp
(defun org-babel-execute:silq (body params)
  "Orgmode Babel Silq evaluate function for `BODY' with `PARAMS'."
  (let* ((cmd "TMP=$(mktemp --suffix=.slq); cat > $TMP; ~/.local/bin/silq $TMP --run 2>&1; rm $TMP"))
    (org-babel-eval cmd body)))
#+end_src

And a simple major mode, which appears to be a prerequisite for fontification of Org source blocks.
#+begin_src emacs-lisp
(define-derived-mode silq-mode prog-mode "Silq"
  "Major mode for editing Silq code."

  ;; Fontification
  ;; (setq-local font-lock-defaults '((silq-font-lock-keywords)))
  )
#+end_src
** Coq
For some reason, ~undo-tree-mode~ is disabled in Coq buffers. Let’s turn it back on.
#+begin_src emacs-lisp
(add-hook! 'coq-mode-hook
 (undo-tree-mode))
#+end_src

I’d like to not use some of the “prettified” symbols in ~company-coq-mode~ for which Fira Code already has better-looking ligatures. It’s mostly the arrows.
#+begin_src emacs-lisp
(after! company-coq
  (let ((rejected-pretty-symbols '("->" "<-" "<->" ">->" "~>" "~~>" "-->" "<--" "=>" "::" "|-")))
    (setq company-coq-prettify-symbols-alist
          (-filter (lambda (s) (not (member (car s) rejected-pretty-symbols)))
                   company-coq-prettify-symbols-alist))
    (setq coq-prettify-symbols-alist
          (-filter (lambda (s) (not (member (car s) rejected-pretty-symbols)))
                   coq-prettify-symbols-alist))))
#+end_src
** Lilypond
There /is/ a ~lilypond-mode~, but it doesn’t seem to be on MELPA, and it maybe doesn’t work.
** Company
:PROPERTIES:
:ID:       1d9d34ee-2b1a-4352-8e2e-683466b986cc
:END:
Will this make ~company-mode~ work?
 for.
#+BEGIN_SRC emacs-lisp
(set-company-backend!
  '(c-mode
    haskell-mode
    emacs-lisp-mode
    lisp-mode
    sh-mode
    python-mode
    julia-mode
    rust-mode
    js-mode)
  '(:separate
    ;; company-tabnine
    company-files
    company-yasnippet))

(setq +lsp-company-backend
      '(company-lsp :with company-tabnine :separate))
#+END_SRC
** Tree-sitter
:PROPERTIES:
:ID:       3e9a565b-ea3f-494a-8712-90b88e7d6b48
:END:
Shamelessly borrowed from [[https://hungyi.net/posts/use-emacs-tree-sitter-doom-emacs/][this]] blog post.
#+begin_src emacs-lisp :tangle no
(use-package! tree-sitter
  :config
  (require 'tree-sitter-langs)
  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+end_src
* Utilities
** Terminal emulation
* Org-mode
** Main Org-mode settings
:PROPERTIES:
:ID:       46fc652b-fae9-409f-9c93-3a76cac97f18
:END:
A little helper function for completing latex fragments. Some notes:
+ Newlines aren’t working. It might be that you’re supposed to use a "character class" like ~[:space:]~ or ~\s~, but neither of these
+ ~looking-back~ is known to be quite slow. See [[https://emacs.stackexchange.com/a/12744][this answer]].

#+BEGIN_SRC emacs-lisp
(defun my/latex-fragment-completion ()
  ;; This regexp will trigger LaTeX compilation whenever following a '$' character by an optional punctuation character and whitespace.
  (when (looking-back "\$[\.,!?-]?\s")
    (save-excursion
      (backward-char 1)
      (org-toggle-latex-fragment))))
#+END_SRC

All the overridden org-mode variables:

#+BEGIN_SRC emacs-lisp
(after! org
  (setq
   org-log-done 'time ;; when finishing a task, log the time
   org-hide-emphasis-markers t
   org-export-headline-levels 5
   org-id-link-to-org-use-id t
   org-startup-with-latex-preview 'nil
   org-agenda-files (directory-files my/org-agenda-dir t "\.org$")
   org-latex-create-formula-image-program 'imagemagick
   org-latex-pdf-process '("latexmk  -shell-escape -bibtex -pdf %f")
   olivetti-body-width 0.6)
  ;;uncomment this to use "minted" for listings
  ;;org-latex-listings 'minted)

  (setq org-highlight-latex-and-related '(latex))
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.0))
  (setq my/org-latex-packages-extra
        '("tikz"
          "minted"
          ;; "tikz-cd"
          "physics"     ;; bras and kets, etc.
          "cmll"
          "bussproofs"  ;; sequent calculus
          "mathtools")
        ;; This assumes that there was nothing in this variable to begin with!
        org-latex-packages-alist (mapcar (lambda (package) `("" ,package t))
                                         my/org-latex-packages-extra))

  ;; FIXME This will render the bullets more correctly!
  ;; NOTE This isn’t working right now for some reason
  ;; (set-face-attribute 'org-superstar-header-bullet nil :family "Fira Code")
  ;; If this doesn’t render correctly: it’s a book
  (push '("physical" . "") org-pretty-tags-surrogate-strings)
  ;; If this doesn’t render correctly: it’s a sticky note
  (push '("noter" . "") org-pretty-tags-surrogate-strings)
  ;; If this doesn’t render correctly: it’s a pencil
  (push '("noter" . "") org-pretty-tags-surrogate-strings)
  ;; If this doesn’t render correctly: it’s a bunch of blocks
  (push '("material" . "") org-pretty-tags-surrogate-strings)
  ;; If this doesn’t render correctly: it’s a beaker
  ;;
  ;; This tag is for questions I want to look into and read the literature on.
  (push '("research" . "") org-pretty-tags-surrogate-strings)
  ;; This tag is mostly for journal entries, and _should_ be a lightbulb
  (push '("idea" . "") org-pretty-tags-surrogate-strings)
  ;; If this doesn’t render correctly: it’s a
  ;; This tag is for open problems
  (push '("open" . "🯄") org-pretty-tags-surrogate-strings)

  ;; Overwrites the app that should be used to open pdfs from Emacs. This was
  ;; originally set to ~default~ in org.el, which uses the "system default pdf
  ;; viewer." You should also figure out how to it figures out what that is, and
  ;; how to change it. There seems to be no builtin for overwriting alists, but
  ;; this is earlier entries shadow later entries, so this has the same effect.
  (add-to-list 'org-file-apps '("\\.pdf\\'" . emacs)))


;; TODO break out a lot of these hooks into some appropriate ‘text-mode’ hook.
(add-hook! 'org-mode-hook
  (when (string-prefix-p my/org-agenda-dir (buffer-file-name))
    (flycheck-mode -1))
  (visual-line-mode) ;; improved wrapping
  (org-indent-mode)
  (electric-quote-mode) ;; replace “ and ”.
  (display-line-numbers-mode -1)
  (if (not (eq major-mode 'treemacs-mode))
      (progn
        (olivetti-mode)
        ;; (org-superstar-mode)
        (org-variable-pitch-minor-mode)))
  (org-pretty-tags-mode)
  ;; disable latex fragment compilation for now
  ;; (add-hook 'post-self-insert-hook #'my/latex-fragment-completion 'append 'local)
  )
#+END_SRC

A utility function to clear LaTeX previews. It might be nice to make this a native Emacs function instead of shelling out.

#+begin_src emacs-lisp
(defun my/clear-latex-preview-images ()
  (interactive)
  (shell-command
   (concat "rm " org-preview-latex-image-directory "*")))
#+end_src

Another thing I want: I often insert drawers of questions, and would like a special keybinding to make that easier.

#+BEGIN_SRC emacs-lisp

(map! :after org
      :map org-mode-map
      :localleader
      :desc "Insert questions"
      "Q" #'(lambda () (org-insert-drawer "QUESTIONS")))
#+END_SRC

I'd also like to use the ~:ignore:~ tag from ~ox-extra~ in order to exclude headers from export while including their contents.

#+begin_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+end_src

** Notebook emulation
:PROPERTIES:
:ID:       8debee11-bc46-4b39-aa78-78b9384b73a7
:END:
I want to be able to use Org for literate programming in a variety of scripting languages. In particular, I’d like to be able to match the functionality of Jupyter notebooks without dealing with its json format, clunky browser interface, and so on.

First, we might like to disable ~jupyter-repl-interaction-mode~ in source block editor buffers, thereby unbinding ~C-c C-c~ from evaluation. This conflicts with the source-editing buffer commit command. This could be an issue with Doom’s ~+jupyter~ option.

Unfortunately, this does not quite work. It horribly messes up editing of SRC blocks. If you try to edit them in the org buffer, it blocks, and must be edited in a background blah-mode buffer, but ~C-c C-c~ does not actually commit the changes in the org-edit buffer. Note that this is only true once a jupyter session has been started with jupyter-run-repl. You can still exit with ~C-c '~.

#+BEGIN_SRC emacs-lisp
(map! :after org
      :map org-src-mode-map
      :localleader
      "'" #'org-edit-src-exit)
#+END_SRC

We already have ~Enter~ mapped to execution of a single source block, but it would be nice to map a few more functions.

#+BEGIN_SRC emacs-lisp
(map! :after org
      :map org-mode-map
      :localleader
      :prefix ("j" . "jupyter")
      :desc "Clear results" "C" #'jupyter-org-clear-all-results
      :desc "Interrupt kernel" "I" #'jupyter-org-interrupt-kernel
      :desc "Run REPL" "r" #'jupyter-run-repl
      :desc "Restart kernel" "R" #'jupyter-repl-restart-kernel
      :desc "Execute subtree" "S" #'jupyter-org-execute-subtree
      :desc "Goto error" "e" #'jupyter-org-goto-error
      :desc "Goto block" "g" #'jupyter-org-jump-to-block
      :desc "Insert block" "i" #'jupyter-org-insert-src-block
      :desc "Merge blocks" "m" #'jupyter-org-merge-blocks
      :desc "Execute and advance" "n" #'jupyter-org-execute-and-next-block
      :desc "Execute to point" "p" #'jupyter-org-execute-to-point
      :desc "Split block" "s" #'jupyter-org-split-src-block)
#+END_SRC

I’d also like to have a capture template for making ~jupyter-python~ notebooks. That can happen another time.

I’d also like to have a function that selects a subtree via ~ivy~ (doing something like ~org-goto~) and evaluates it (doing something like ~jupyter-execute-subtree~), all in-place.

Finally, let’s set some defaults that make it relatively easy to run a kernel in the common case. The “session” variable /should/ almost always be overridden in practice.

#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args:jupyter-python
      '((:async . "yes")
        (:session . "py")
        (:kernel . "python3")))

(setq org-babel-default-header-args:jupyter-julia
      '((:async . "yes")
        (:session . "jl")
        (:kernel . "julia-1.5")))
#+END_SRC

** Citation management
:PROPERTIES:
:ID:       244864d8-45b8-4e58-8e28-dea85cb32ff1
:END:
This is a great big mess. You really need to figure it out at some point.

And these are some similar bindings for ~org-roam-bibtex~. I probably want this to be /globally/ accessible, really, but I’m not sure where to bind it. Looks like ~SPC-z~ is open, but I also want org-specific functions bound to the same cluster.

#+BEGIN_SRC emacs-lisp
(map! ;; :map org-mode-map
      ;; :localleader
      :leader
      :prefix ("\"" . "references")
      "b" #'ivy-bibtex)
#+END_SRC

The ~bibtex~ package seems to have changed in order to require the user to set this key explicitly in order to look up a PDF from the bibtex file.
#+begin_src emacs-lisp
(after! bibtex
  (setq bibtex-completion-pdf-field "file"))
#+end_src

I also want to change ~ivy-bibtex-default-action~, which in the default configuration (~ivy-bibtex-open-any~) simply opens a document. I’d like the option, for example, to open my notes instead. ~ivy-dispatching-call~ provides this. But it doesn't take a ~candidate~ argument like ~ivy-bibtex-open-any~ does, so we need to assign a lambda that ignores this argument.

There’s a slight issue: see the ~ivy-set-actions~ block in  ~ivy-bibtex.el~. A whole lot more functions are bound than are visible when we call this function. Why?

#+BEGIN_SRC emacs-lisp
(after! ivy-bibtex
  (setq ivy-bibtex-default-action
        #'(lambda (candidate) (ivy-dispatching-call))))
#+END_SRC

Here are some settings from the not-yet-merged ~biblio~ module, which I have in my private modules directory. I’m not sure if these settings are correct or even necessary. In particular, I don’t think I’m using ~+biblio-pdf-library-dir~ at all.

# #+BEGIN_SRC emacs-lisp
# ;; Should this be ~after!~ something?
# ;; TODO review this section, see which settings you actually need.
# (after! org-ref-bibtex
#   (setq! +biblio-pdf-library-dir (concat org-directory "/biblio/pdfs/")
#          +biblio-default-bibliography-files (directory-files
#                                              (concat org-directory "/biblio/bibs")
#                                              t "\.bib$")
#          +biblio-notes-path (concat org-roam-directory "/refs/")))
# #+END_SRC

Huh, weird, are these not doing anything any more? Did it break in an update? Maybe we should be using... This variable?

#+begin_src emacs-lisp
(after! bibtex-completion
    (setq! bibtex-completion-bibliography
           (directory-files
            (concat org-directory "/biblio/bibs")
            t "\.bib$")))
#+end_src

Ok, I don’t know what to do here. This variable is changed, some time during startup, from its default value to ~org-ref-get-pdf-filename-helm-bibtex~, a variable which is only used in one place directly beneath this. I can’t figure out why this is happening. Try using ~debug-watch~ to see if you can get somewhere with it. For now we’ll just hideously, manually reset it.
#+begin_src emacs-lisp
;; TODO get rid of this!
(after! org-ref
  (setq! org-ref-open-pdf-function 'org-ref-open-pdf-at-point))
#+end_src

We have to ensure that we open pdfs by looking up the bibliography ~file~ field, rather than by looking in a pdf directory.
#+BEGIN_SRC emacs-lisp
(after! org-roam-bibtex
  ;; The following is probably not right.
  (setq! org-ref-get-pdf-filename-function 'org-ref-get-pdf-filename-helm-bibtex)
  (setq! orb-persp-project `("notes" . ,+biblio-notes-path)))
#+END_SRC

Now, in order for ~org-ref-open-notes-at-point~ (via ~orb-edit-notes~) to work properly, I need in particular to set some ~orb-templates~ that will put the notes in the right subdirectory and so forth. To get started, I’ve *shamelessly* copied the templates of the illustrious [[https://github.com/zaeph/.emacs.d/blob/0f4bf9a500ef6397b93c41cb51602bea9ab9a4c3/init.el][Leo Vivier]], tweaking them only a little to my tastes.
#+BEGIN_SRC emacs-lisp
(defvar my/orb-header
          (concat
           "#+title: ${title}\n"
           "#+author: ${author-or-editor}")
  "Format of the header to use for `orb-templates'.")

(setq! orb-templates
       `(("r" "ref" plain
          (function org-roam-capture--get-point)
          ""
          :file-name "refs/${slug}"
          :head ,(concat
                  my/orb-header "\n"
                  "#+roam_key: ${ref}\n"
                  "#+created: %U\n"
                  "#+last_modified: %U\n\n")
          :unnarrowed t)
         ("p" "ref + physical" plain
          (function org-roam-capture--get-point)
          ""
          :file-name "refs/${slug}"
          :head ,(concat
                  my/orb-header "\n"
                  "#+roam_key: ${ref}\n"
                  "\n"
                  "* Notes :physical:\n"))
         ("n" "ref + noter" plain
          (function org-roam-capture--get-point)
          ""
          :file-name "refs/${slug}"
          :head ,(concat
                  my/orb-header "\n"
                  "#+roam_key: ${ref}\n\n"
                  "* Notes :noter:\n"
                  ":PROPERTIES:\n"
                  ":NOTER_DOCUMENT: %(orb-process-file-field \"${=key=}\")\n"
                  ":NOTER_PAGE:\n"
                  ":END:\n"))))
#+END_SRC

I’d also like to be able to pop up a temporary buffer with the abstract of a citation.

#+BEGIN_SRC emacs-lisp
;; Has a mismatched paren or something
(after! ivy-bibtex
  (defun my/org-ref-show-abstract-at-point ()
    "Show abstract at point"
    (interactive)
    (let* ((results (org-ref-get-bibtex-key-and-file))
           (key (car results))
           (bibfile (cdr results)))
    (save-excursion
      (with-temp-buffer
        (insert-file-contents bibfile)
        (bibtex-set-dialect (parsebib-find-bibtex-dialect) t)
        (bibtex-search-entry key)
        (catch 'done
          (let ((abstract (s-trim (bibtex-autokey-get-field "abstract"))))
            (unless (s-blank? abstract)
              (print abstract)
              (throw 'done nil))))))))

  ;; Add a new hydra head for this action
  ;; (defhydra+ org-ref-cite-hydra ()
  ;;   ("a" my/org-ref-show-abstract-at-point "Show abstract"))
  )
#+END_SRC

I’d also like to use a distinct face for citations.
#+BEGIN_SRC emacs-lisp
(after! 'org-ref
  (set-face-attribute 'org-ref-cite-face nil
                      :inherit 'org-table
                      :weight 'medium))
#+END_SRC

** Org-roam
:PROPERTIES:
:ID:       fc99d163-3392-4c8a-ab98-eb3a7754737a
:END:
#+BEGIN_SRC emacs-lisp
;; org-roam configurations
(after! org-roam
  (setq-default org-roam-directory (concat org-directory "/roam"))
  (after! deft
    (setq-default deft-directory org-roam-directory)))
#+END_SRC

I’m also using ~org-roam-server~ to visualize the org graph. So far, these settings are the defaults from the [[https://github.com/org-roam/org-roam-server#Installation][installation instructions]], except that I’ve incremented to port number to something less common, and removed the ~:ensure~ attribute, which Doom Emacs discourages. Note that I’ve disabled this package for lack of use, so this is commented out for now.

#+BEGIN_SRC emacs-lisp
;; (use-package! org-roam-server
;;   :config
;;   (setq org-roam-server-host "127.0.0.1"
;;         org-roam-server-port 8081
;;         org-roam-server-authenticate nil
;;         org-roam-server-export-inline-images t
;;         org-roam-server-serve-files nil
;;         org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
;;         org-roam-server-network-poll t
;;         org-roam-server-network-arrows nil
;;         org-roam-server-network-label-truncate t
;;         org-roam-server-network-label-truncate-length 60
;;         org-roam-server-network-label-wrap-length 20))
#+END_SRC

** Org-noter
:PROPERTIES:
:ID:       6a86e991-0d58-4385-93bb-8b38454fe095
:END:
By default, Noter opens a new frame, although this is rarely the behavior I actually want. Symmetrically, we should keep the frame at the end of the Noter session. Let’s also change the default split fraction when editing notes.

#+BEGIN_SRC emacs-lisp
(after! org-noter
  (setq! org-noter-always-create-frame nil
         org-noter-kill-frame-at-session-end nil
         org-noter-doc-split-fraction '(0.60 . 0.40)))
#+END_SRC

Let’s also set a key to kill the noter session.
#+BEGIN_SRC emacs-lisp
(map! :after org-noter
      :map org-noter-doc-mode-map
      :localleader
      :desc
      "Kill noter session"
      "k" #'org-noter-kill-session)
#+END_SRC

We also want closing the Noter document buffer to quit the Noter session. This seems to actually be a /default/ behavior, since ~q~ is bound to ~org-noter-kill-session~ in ~org-noter-doc-mode~. But in practice this key just closes the doc buffer; it doesn’t remove the notes window as well.

** Org-journal
:PROPERTIES:
:ID:       771c50c3-a285-4011-a51b-47ea18f0517c
:END:
#+BEGIN_SRC emacs-lisp
;; org-journal configurations
(after! org-journal
  (setq-default
   org-journal-dir (concat org-directory "/journal")
   org-journal-encrypt-journal t
   org-journal-file-type 'weekly
   org-extend-today-until 4      ;; burn the midnight oil
   ))
#+END_SRC

** Symbols
:PROPERTIES:
:ID:       b5814713-f40c-4259-8638-1419fb1f431e
:END:
See, as usual, [[https://tecosaur.github.io/emacs-config/config.html#symbols][tecosaur’s config]] for lots of good hints. I’ve shamelessly snagged these as the basis for my custom ligatures. All of tecosaur’s are still in here, but I think I’ll prune a lot of them.

All right, this is almost working. The major problem that remains is that the Emacs Lisp symbol renders as what appears to be the TOR onion logo. Also, if I add the ~+fira~ option to the ~ligatures~ module, colons start rendering as some kind of unusual letter /k/, and other undesired things. I’m not sure how to get both Fira ligatures and the others working together.

#+BEGIN_SRC emacs-lisp
(after! org
  (appendq! +ligatures-extra-symbols
            `(:checkbox      "☐"
              :pending       "◼"
              :checkedbox    "☑"
              :list_property "∷"
              :results       "🠶"
              :end           "∎"
              :options       "⌥"
              :latex_header  "⇥"
              :latex_class   "🄲"
              :beamer_header "↠"
              :jupyter_py    ""
              :jupyter_jl    "⛬"
              :emacs_lisp    ""
              :nix           ""
              :begin_export  "⯮"
              :end_export    "⯬"
              ;; :em_dash       "—"
              ;; :en_dash       "–"
              ))
  (set-ligatures! 'org-mode
    :merge t
    :checkbox      "[ ]"
    :pending       "[-]"
    :checkedbox    "[X]"
    :list_property "::"
    :results       "#+RESULTS:"
    :end           ":END:"
    :end           ":end:"
    :options       "#+OPTIONS:"
    :latex_class   "#+LATEX_CLASS:"
    ;; :latex_header  "#+LATEX_HEADER:"
    :beamer_header "#+BEAMER_HEADER:"
    :jupyter_py    "jupyter-python"
    :jupyter_jl    "jupyter-julia"
    :emacs_lisp    "emacs-lisp"
    :nix           "nix"
    :begin_quote   "#+BEGIN_QUOTE"
    :begin_quote   "#+begin_quote"
    :end_quote     "#+END_QUOTE"
    :end_quote     "#+end_quote"
    :begin_example "#+BEGIN_EXAMPLE"
    :begin_example "#+begin_example"
    :end_example "#+END_EXAMPLE"
    :end_example "#+end_example"
    :begin_export  "#+BEGIN_EXPORT"
    :end_export    "#+END_EXPORT"
    ;; :em_dash       "---"
    ;; :en_dash       "--"
    ))
#+END_SRC

* LaTeX
:PROPERTIES:
:ID:       6904a4b0-8a10-4f40-a67d-c53d27a3533d
:END:
Maybe this and ~org-mode~ should be refiled under [[*Documents][Documents]]; I’m not sure. It has its own top-level header for now.

Let’s first set some defaults:
#+BEGIN_SRC emacs-lisp
(after! tex-mode
  (setq +latex-viewers '(pdf-tools)))
#+END_SRC

Doom doesn’t supply a lot of evil bindings for TeX by default, so let’s do that, too.

#+BEGIN_SRC emacs-lisp
(map! :after tex-mode
      :localleader
      "c" #'TeX-command-run-all  ;; compile and view the document
)
#+END_SRC

Finally, pdf popups (which--I think--will mostly come from ~.tex~ documents) should appear on the right-hand side.
#+BEGIN_SRC emacs-lisp
(after! popup
  (set-popup-rule! "^.*.pdf"
    :select nil    ;; don’t focus the window after it opens
    ;; :action
    :side 'right   ;; on the rhs of the screen
    :width 0.5      ;; and fill 50% of it.
    :quit nil      ;; don’t disappear on me
  )
)
#+END_SRC

* Documents
:PROPERTIES:
:ID:       272aa199-7ed5-406c-aebb-6059237a14d8
:END:
Some pdf viewing preferences: start in ~midnight-minor-mode~, and use theme colors.  I’m treating it not as a ‘pdf dark mode,’ but as a ‘pdf themed mode,’ which is what you really want most of the time.
#+BEGIN_SRC emacs-lisp
(defun my/set-pdf-view-midnight-colors ()
  "Sets the colors for viewing pdfs in 'dark mode'"
  (interactive)
  (setq pdf-view-midnight-colors
        (cons (my/theme-color 'fg)
              (my/theme-color 'bg))))

(after! pdf-view (my/set-pdf-view-midnight-colors))

;; Set these colors whenever you load a theme
(add-hook! 'doom-load-theme-hook
           #'my/set-pdf-view-midnight-colors)

;; Start in midnight mode!
(add-hook! 'pdf-view-mode-hook
            #'pdf-view-midnight-minor-mode)
#+END_SRC

We can also read books, and integrate them into our ~org-roam-bibtex~ / ~org-noter~ universe. Let’s set up ~nov.el~:

#+BEGIN_SRC emacs-lisp
(use-package! nov
  :hook (nov-mode . variable-pitch-mode)
  :mode ("\\.\\(epub\\|mobi\\)\\'" . nov-mode))
#+END_SRC

We’re ignoring this function for now, which I’ve yanked from zaeph’s config. There it is bound to ~M-i~. I should also figure out if ~insert-precise-note~ is inserting at mouse in pdfs.

#+BEGIN_SRC emacs-lisp :tangle no
;; This function has been yanked from zaeph’s config.
;; Zaeph just has it bound to "M-i"
(defun my/org-noter-insert-precise-note-dwim (force-mouse)
    "Insert note associated with a specific location.

If in nov-mode, use point rather than the mouse to target the
position."
    (interactive "P")
    (if (and (derived-mode-p 'nov-mode)
             (not force-mouse))
        (let ((pos (if (region-active-p)
                       (min (region-beginning) (point))
                     (point))))
          (org-noter-insert-note pos))
      (org-noter-insert-precise-note)))
#+END_SRC

* Email
:PROPERTIES:
:ID:       dea0c9cc-bd5e-4b0c-80b2-76cfe98b8add
:END:
~mu4e~ doesn’t seem to be loading. Doom Emacs doesn’t find the ~site-lisp~ directory and add it to the load path even after a refresh. Maybe I’m supposed to build Emacs with /with/ the package, but ~mu~ doesn’t seem to be an allowd package in this derivation. Let’s just add it manually, which works just fine.

#+begin_src emacs-lisp
(add-to-list 'load-path "/run/current-system/sw/share/emacs/site-lisp/mu4e")
#+end_src

Here are the public parts of my email configuration. First, we’ll import the bits that I want to keep private. Also, set any variables here that you’d like to be after ~mu4e~ loads.

#+BEGIN_SRC emacs-lisp
(after! mu4e
  (load! "./mu4e-config.el")
  ;; get new email every 5 minutes
  (setq mu4e-update-interval 300))
#+END_SRC

These settings specify how to retrieve mail.

#+BEGIN_SRC emacs-lisp
(setq
 +mu4e-backend 'offlineimap
 mu4e-get-mail-command "offlineimap"
 mu4e-context-policy 'pick-first
 message-kill-buffer-on-exit t
 ;; should just quit when I type `q`
 mu4e-confirm-quit nil)
#+END_SRC

I want some better defaults for formatting (particularly HTML) emails, and to automatically check emails
#+BEGIN_SRC emacs-lisp
(setq org-msg-options
      "html-postamble:nil toc:nil author:nil email:nil \\n:t -:t ^:{} H:5 num:0")
#+END_SRC


And these are just setting up usual text-viewing minor modes. I wonder if I should fold these into ~text-mode~, since they’re redundant with some of the ~org-mode~ minor modes.

#+BEGIN_SRC emacs-lisp
;; TODO are line breaks still not handled correctly?
(add-hook 'mu4e-view-mode-hook 'olivetti-mode)
(add-hook 'mu4e-compose-mode-hook
          '(lambda ()
             (visual-line-mode) ;; improved wrapping
             (olivetti-mode)
             (display-line-numbers-mode -1)
             (use-hard-newlines -1)
             (flyspell-mode))
          t)
#+END_SRC

* Technical drawing
:PROPERTIES:
:ID:       28f0da82-aded-4e24-9911-8f14e095bd3e
:END:
I’d like to be able to run a single command and add or update an ~.svg~ in-place. Here are some little commands to do this, inspired by [[https://castel.dev/post/lecture-notes-2/][Gilles Castel]], whose scripts I’m shamelessly using.

#+BEGIN_SRC emacs-lisp
(defun my/figure-dir ()
  "Return the directory where figures are saved"
  (concat default-directory "figures/"))

(defun my/inkscape-figures ()
  "Creates a new figure in Inkscape"
  (interactive)
  (let*
      ((no-dots directory-files-no-dot-files-regexp)
       (figure-dir (my/figure-dir))
       (figure-name
        ;; get the figure name by asking the user for it
        (progn
          ;; make the figure directory if it doesn’t exist
          (if (not (file-exists-p figure-dir))
              (mkdir figure-dir))
          (concat
           ;; query the user for a figure name
           (completing-read
            "Figure name: "
            (mapcar #'file-name-nondirectory
             (mapcar #'file-name-sans-extension
                   (directory-files figure-dir t no-dots))))))))

    (if (file-exists-p (concat figure-dir figure-name))
      ;; run the command to edit the figure
      (shell-command
       (concat "inkscape-figures edit " figure-dir figure-name))
      ;; otherwise, run the command to create the figure
      (shell-command
       (concat "inkscape-figures create " figure-dir figure-name)))

    ;; return the figure name
    figure-name))
#+END_SRC

I’d also like to provide some convenience functions for automatically inserting these in various text modes. This is a work in progress.

#+BEGIN_SRC emacs-lisp
(defun my/inkscape-figures-insert ()
  "Create or edit and insert in inkscape figure in an Org buffer"
  (interactive)
  (let ((figure-name (my/inkscape-figures)))
    (insert (concat "[[file:" (my/figure-dir) figure-name ".svg]]"))))
#+END_SRC

#  LocalWords:  config namespacing zitieren noter
